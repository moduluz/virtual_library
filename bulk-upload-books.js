require('dotenv').config({ path: '.env.local' });
const fs = require('fs');
const path = require('path');
const { createClient } = require('@supabase/supabase-js');
const csv = require('csv-parser');
const crypto = require('crypto'); // For generating UUIDs

// --- Configuration ---
const CSV_FILE_PATH = 'C:\\Users\\adity\\OneDrive\\Desktop\\New folder\\Book_List(Sheet1).csv';
const SUPABASE_BUCKET_NAME = 'books-pdf';
const DEFAULT_BOOK_STATUS = 'completed';
const USER_ID = 'user_2yLom9w1S5nJDBpxA9u1lkOaNBR';

// CSV Column Names (ensure these exactly match your CSV headers)
const CSV_COLUMN_TITLE = 'title';
const CSV_COLUMN_COVER_URL = 'cover_url';
const CSV_COLUMN_AUTHOR = 'author';
const CSV_COLUMN_LOCAL_PDF_PATH = 'pdf_url'; // This column contains the local path

// --- Supabase Initialization ---
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY; // <--- CHANGE THIS LINE

if (!supabaseUrl || !supabaseServiceKey) {
  console.error('Error: Supabase URL or Service Key is not defined in .env.local.');
  console.error('Please ensure NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_KEY are set.');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseServiceKey);

// --- Helper Functions ---
function cleanLocalPath(rawPath) {
  if (!rawPath) return null;
  // Remove leading/trailing triple quotes if present, then single quotes
  let cleanedPath = rawPath.trim();
  if (cleanedPath.startsWith('"""') && cleanedPath.endsWith('"""')) {
    cleanedPath = cleanedPath.substring(3, cleanedPath.length - 3);
  }
  // Remove leading/trailing single quotes if present (some CSV exports might add them)
  if (cleanedPath.startsWith('"') && cleanedPath.endsWith('"')) {
    cleanedPath = cleanedPath.substring(1, cleanedPath.length - 1);
  }
  return cleanedPath;
}

async function processBook(bookData) {
  const {
    [CSV_COLUMN_TITLE]: title,
    [CSV_COLUMN_COVER_URL]: coverUrl,
    [CSV_COLUMN_AUTHOR]: author,
    [CSV_COLUMN_LOCAL_PDF_PATH]: rawLocalPdfPath,
  } = bookData;

  if (!title || !author) {
    console.warn('Skipping row due to missing title or author:', bookData);
    return;
  }

  const localPdfPath = cleanLocalPath(rawLocalPdfPath);
  let publicPdfUrl = null;

  console.log(`\nProcessing book: "${title}"`);

  if (localPdfPath) {
    if (!fs.existsSync(localPdfPath)) {
      console.error(`  ERROR: PDF file not found at path: ${localPdfPath} for book "${title}". Skipping PDF upload.`);
    } else {
      try {
        console.log(`  Uploading PDF from: ${localPdfPath}`);
        const fileBuffer = fs.readFileSync(localPdfPath);
        const originalFileName = path.basename(localPdfPath);
        const fileExtension = path.extname(originalFileName) || '.pdf'; // Ensure .pdf if no extension
        const uniqueFileNameInStorage = `file-${crypto.randomUUID()}${fileExtension}`;
        const storagePath = `${USER_ID}/${uniqueFileNameInStorage}`;

        const { data: uploadData, error: uploadError } = await supabase.storage
          .from(SUPABASE_BUCKET_NAME)
          .upload(storagePath, fileBuffer, {
            contentType: 'application/pdf',
            upsert: false, // Don't overwrite if somehow a file with the same random name exists
          });

        if (uploadError) {
          console.error(`  ERROR uploading PDF for "${title}":`, uploadError.message);
        } else {
          const { data: urlData } = supabase.storage
            .from(SUPABASE_BUCKET_NAME)
            .getPublicUrl(storagePath);
          publicPdfUrl = urlData.publicUrl;
          console.log(`  PDF uploaded successfully: ${publicPdfUrl}`);
        }
      } catch (e) {
        console.error(`  ERROR processing PDF file for "${title}":`, e.message);
      }
    }
  } else {
    console.log(`  No local PDF path provided for "${title}". Skipping PDF upload.`);
  }

  // Insert book data into Supabase 'books' table
  const bookToInsert = {
    userId: USER_ID,
    title: title,
    author: author,
    coverUrl: coverUrl || null, // Handle if cover_url is empty
    status: DEFAULT_BOOK_STATUS,
    pdf_url: publicPdfUrl,
    // 'dateAdded' will default to now() by database
    // 'id' will be auto-generated by database
    // Other nullable fields (isbn, description, genre, pageCount, etc.) will be null
  };

  try {
    console.log(`  Inserting book metadata into database for "${title}"...`);
    const { data: insertData, error: insertError } = await supabase
      .from('books')
      .insert(bookToInsert)
      .select();

    if (insertError) {
      console.error(`  ERROR inserting book "${title}" into database:`, insertError.message);
      if (insertError.details) console.error('  Details:', insertError.details);
    } else {
      console.log(`  Book "${title}" (ID: ${insertData ? insertData[0]?.id : 'N/A'}) inserted successfully into database.`);
    }
  } catch (e) {
    console.error(`  CRITICAL ERROR inserting book "${title}" into database:`, e.message);
  }
}

// --- Main Execution ---
async function main() {
  console.log('Starting bulk book upload process...');
  const results = [];

  fs.createReadStream(CSV_FILE_PATH)
    .pipe(csv())
    .on('data', (data) => results.push(data))
    .on('end', async () => {
      console.log(`\nFinished reading CSV. Found ${results.length} rows to process.`);
      for (const book of results) {
        await processBook(book); // Process books one by one to avoid overwhelming services
      }
      console.log('\n--- Bulk upload process finished. ---');
      console.log('Please check the console output for errors or successes for each book.');
    })
    .on('error', (error) => {
      console.error('Error reading CSV file:', error.message);
    });
}

main();